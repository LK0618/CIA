{"meta":{"title":"Citrus","subtitle":null,"description":null,"author":"Citrus","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"jsp中request，response，session方法","slug":"jsp中request,response,session的方法","date":"2019-10-31T12:52:20.000Z","updated":"2019-11-06T02:31:17.931Z","comments":true,"path":"2019/10/31/jsp中request,response,session的方法/","link":"","permalink":"http://yoursite.com/2019/10/31/jsp中request,response,session的方法/","excerpt":"一、request对象客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。1.返回指定属性的属性值 1object getAttribute(String name) 2.返回所有可用属性名的枚举 1Enumeration getAttributeNames() 3.返回字符编码方式 1String getCharacterEncoding()","text":"一、request对象客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。1.返回指定属性的属性值 1object getAttribute(String name) 2.返回所有可用属性名的枚举 1Enumeration getAttributeNames() 3.返回字符编码方式 1String getCharacterEncoding() 4.返回请求体的长度（以字节数） 1int getContentLength() 5.得到请求体的MIME类型 1String getContentType() 6.得到请求体中一行的二进制流 1ServletInputStream getInputStream() 7.返回name指定参数的参数值 1String getParameter(String name) 8.返回可用参数名的枚举 1Enumeration getParameterNames() 9.返回包含参数name的所有值的数组 1String[] getParameterValues(String name) 10.返回请求用的协议类型及版本号 1String getProtocol() 11.返回请求用的计划名,如:http.https及ftp等 1String getScheme() 12.返回接受请求的服务器主机名 1String getServerName() 13.返回服务器接受此请求所用的端口号 1int getServerPort() 14.返回解码过了的请求体 1BufferedReader getReader() 15.返回发送此请求的客户端IP地址 1String getRemoteAddr() 16.返回发送此请求的客户端主机名 1String getRemoteHost() 17.设置属性的属性值 1void setAttribute(String key,Object obj) 18.返回一虚拟路径的真实路径 1String getRealPath(String path) 二、response对象response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它，它是HttpServletResponse类的实例。1.返回响应用的是何种字符编码 1String getCharacterEncoding() 2.返回响应的一个二进制输出流 1ServletOutputStream getOutputStream() 3.返回可以向客户端输出字符的一个对象 1PrintWriter getWriter() 4.设置响应头长度 1void setContentLength(int len) 5.设置响应的MIME类型 1void setContentType(String type) 6.重新定向客户端的请求 1sendRedirect(java.lang.String location) 三、session对象session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.1.返回SESSION创建时间 1long getCreationTime() 2.返回SESSION创建时JSP引擎为它设的惟一ID号 1public String getId() 3.返回此SESSION里客户端最近一次请求时间 1long getLastAccessedTime() 4.返回两次请求间隔多长时间此SESSION被取消(ms) 1int getMaxInactiveInterval() 5.返回一个包含此SESSION中所有可用属性的数组 1String[] getValueNames() 6.取消SESSION，使SESSION不可用 1void invalidate() 7.返回服务器创建的一个SESSION,客户端是否已经加入 1boolean isNew() 8.删除SESSION中指定的属性 1void removeValue(String name) 9.设置两次请求间隔多长时间此SESSION被取消(ms) 1void setMaxInactiveInterval()","categories":[],"tags":[]},{"title":"jsp实现页面跳转的几种方式","slug":"jsp实现页面跳转的几种方式","date":"2019-10-30T09:38:39.664Z","updated":"2019-10-31T00:56:01.181Z","comments":true,"path":"2019/10/30/jsp实现页面跳转的几种方式/","link":"","permalink":"http://yoursite.com/2019/10/30/jsp实现页面跳转的几种方式/","excerpt":"一、使用href超链接标记（客户端跳转）二、提交表单（客户端跳转）123456789 &lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;page2.jsp&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转1&quot;&gt; &lt;/form&gt; &lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;page2.jsp&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转1&quot;&gt; &lt;/form&gt;","text":"一、使用href超链接标记（客户端跳转）二、提交表单（客户端跳转）123456789 &lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;page2.jsp&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转1&quot;&gt; &lt;/form&gt; &lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;page2.jsp&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转1&quot;&gt; &lt;/form&gt; 三、Javascrip事件（客户端跳转）1234567891011&lt;input type=&quot;button&quot; value=&quot;跳转2&quot; onclick=&quot;next()&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; function next()&#123; window.location = &quot;page2.jsp&quot;; &#125; &lt;/script&gt; 四、使用response对象 (客户端跳转)(重定向)12345 &lt;% response.sendRedirect(&quot;page2.jsp&quot;); %&gt; //sendRedirect()可以带参数传递,后面应该紧跟一句return &lt;% response.setHeader(&quot;Refresh&quot;, &quot;1;url=page2.jsp&quot;); %&gt; //1秒后,刷新,并跳到,page2.jsp页面 五、使用forward动作标记 (服务器端跳转)(转发)12 jsp自带的forword标签来实现跳转 &lt;jsp:forward page=&quot;page2.jsp&quot; /&gt; 六、 使用RequestDispatcher类 (服务器端跳转)(转发) 1 &lt;% request.getRequestDispatcher(&quot;page2.jsp&quot;).forward(request, response);%&gt; response重定向和forward跳转和RequestDispatcher的区别（1）response重定向1234执行完页面的所有代码，再跳转到目标页面。跳转到目标页面后，浏览器地址栏中的URL会改变。在浏览器端重定向。可以跳转到其它服务器上的页面，response.sendRedirect(“http://www.baidu.com”) （2）forward跳转12345forward动作标记之后的代码，不再执行，直接跳转到目标页面。跳转到目标页面后，浏览器地址栏中的URL不会改变。在服务器端重定向。无法跳转到其它服务器上的页面。指定目标页面时，既可以使用绝对路径，也可以使用相对路径。 （3）RequestDispatcher跳转12345执行完所有代码，包括RequestDispatcher之后的所有代码，再跳转到目标页面。跳转到目标页面后，浏览器地址栏中的URL不会改变。在服务器端重定向。无法跳转到其它服务器上的页面。指定目标页面时，只能使用绝对路径。","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-10-13T14:52:20.000Z","updated":"2019-10-31T00:58:41.313Z","comments":true,"path":"2019/10/13/我的第一篇博客/","link":"","permalink":"http://yoursite.com/2019/10/13/我的第一篇博客/","excerpt":"JAVA知识点总结第二章 类和对象 1.面向对象概念： 2.类的创建 12- 语法：public class 类名&#123;&#125;- File---&gt;new---&gt;class---&gt;类名 3.创建对象 12- 类名 对象名=new 类名();- 对象名.方法名(); 对象名.属性","text":"JAVA知识点总结第二章 类和对象 1.面向对象概念： 2.类的创建 12- 语法：public class 类名&#123;&#125;- File---&gt;new---&gt;class---&gt;类名 3.创建对象 12- 类名 对象名=new 类名();- 对象名.方法名(); 对象名.属性 4.构造方法：方法名和类名相同,没有返回值 123- public class 类名&#123;- public 类名()&#123;&#125;//主要的做用是初始化操作- &#125; 5.构造方法重载 在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法 1234- public class 类名&#123;- public 类名()&#123;&#125;- public 类名(String name,int age)&#123;&#125;- &#125; 6.构造方法的执行 12- new 类名();---&gt;执行构造方法- super();---&gt;执行了父类的构造方法 7.static静态修饰符 静态修饰符可以修饰属性，方法，代码块 类名.属性 类名.方法名 8.java内存（栈和堆，static，方法区，gc（垃圾回收机制）） 第三章 面向对象三大特征—封装 1.封装的概念 2.封装的步骤 1.把属性私有化（private） 2.对这些属性设置get和set方法 3.调用处理这些方法 3.封装的作用：避免一些用一些不合乎常理的操作 4.修饰符 1234- public---&gt;公共的：在一个项目中都可以访问，权限最高- private---&gt;私有的：只能在本类中进行访问，权限最低- protected---&gt;安全的，受保护的：同一个包能进行访问，继承中之类可以访问父类- default---&gt;默认的：同一个包能访问 第四章 面向对象三大特征—继承 1.继承的概念：父亲儿子，电影《西虹市首富》 2.继承的关键字：extends 3.继承的语法： 1public class 类名 extends 父类&#123;&#125; 4.使用，在之类中： 可以直接调用父类的非私有属性和方法 可以用super.方法 super.属性 5.父类构造方法调用：super(); 调用父类的构造方法必须在之类中调用 必须实在之类构造方法的第一行代码 6.重写@Override 必须继承 方法名一致，参数个数，顺序，类型全部一致 第五章 面向对象（多态） 1.多态的概念 2.多态的必要条件 继承 重写 父类引用指向子类对象（向上转型） 3.多态的使用 1234567891011121314151617- public class Father&#123;- public void cooking()&#123;- System.out.println(&quot;米饭&quot;);- &#125;- &#125;- public class Son extends Father&#123;- @Override- public void cooking()&#123;- System.out.println(&quot;熬粥&quot;);- &#125;- &#125;- public class Test &#123;- public static void main(String[] args) &#123;- Father son=new Son();- son.cooking();- &#125;- &#125; 4.向下转型 Son son=(Son)father; 第六章 抽象 1.抽象的概念 2.抽象的关键字 abstract 可以修饰类，可以修饰方法 3.抽象的用法 //抽象类 public abstract class 类名{ //抽象方法没有方法体 public abstract void 方法名(); } //当父类是抽象类的时候，子类必须重写父类里面的抽象方法 4.final修饰符：最终的 修饰变量，修饰方法，修饰类 1.当修饰变量时，变量转换成常量，常量的值不能改变 1final int a=18;//a=18;不能改变,必须给一个初始值 2.当修饰方法时，该方法不能被重写 3.当修饰类时，该类不能被继承 第七章 接口 1.接口的概念 2.接口的关键字 interface 3.接口的语法 123- public interface 接口名&#123;&#125;- File---&gt;new---&gt;interface//创建接口- 4.接口的用法 实现接口的关键字 implements public interface 接口名{ //接口是纯抽象类 //接口里面的方法都是抽象方法 12345678910111213- void setData();- &#125;- public class Play implements 接口名&#123;- @Override- void setData()&#123;- &#125;- &#125;- public class Test &#123;- public static void main(String[] args) &#123;- Play play=new Play();- play.setData();- &#125;- &#125; 注意接口可以进行多继承 1public interface 接口名 extends 接口名，接口名&#123;&#125; 一般用法 1public class 类名 extends 父类 implements 接口，接口&#123;&#125; 第八章 集合框架 1.ArrayList 1.用法 123- ArrayList list=new ArrayList();- list.add();//添加数据- list.get();//获取数据 2.Map 用法 123- Map map=new HasMap();- map.put(key,value);//key不能重复- map.get(key);//获取key对象的value 3.泛型 用法 123- ArrayList&lt;String&gt; list=new ArrayList&gt;&lt;String&gt;();- Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();- ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();","categories":[],"tags":[]}]}