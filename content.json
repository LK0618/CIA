{"meta":{"title":"Citrus","subtitle":null,"description":null,"author":"Citrus","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"jsp中三种弹出对话框的用法示例(转载)","slug":"JSP中三种弹出对话框的用法实例(转载)","date":"2019-11-07T09:23:20.000Z","updated":"2019-11-15T02:37:25.755Z","comments":true,"path":"2019/11/07/JSP中三种弹出对话框的用法实例(转载)/","link":"","permalink":"http://yoursite.com/2019/11/07/JSP中三种弹出对话框的用法实例(转载)/","excerpt":"jsp网页在与用户交互的过程中，有时需要弹出提示框，通知用户一些信息，如登录密码错误等在做JSP网页项目中， 实践并总结了三种有效的方式方式1：jsp前端1234&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;alert(&quot;您还没有登录，请登录...&quot;);window.document.location.href=&quot;userlogin.html&quot;;&lt;/script&gt;","text":"jsp网页在与用户交互的过程中，有时需要弹出提示框，通知用户一些信息，如登录密码错误等在做JSP网页项目中， 实践并总结了三种有效的方式方式1：jsp前端1234&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;alert(&quot;您还没有登录，请登录...&quot;);window.document.location.href=&quot;userlogin.html&quot;;&lt;/script&gt; 方式2：java后台123456789public void popAlert() &#123;response.setCharacterEncoding(&quot;utf-8&quot;);PrintWriter out = response.getWriter();out.print(&quot;&lt;script&gt;alert(&apos;您还没有登录，请登录...&apos;); window.location=&apos;userlogin.html&apos; &lt;/script&gt;&quot;);out.flush();out.close();&#125; 方式3：java后台 + jsp前端(1).java后台代码段 123456public void popAlert() &#123;request.setAttribute(&quot;loginError&quot;, &quot;您还没有登录，请登录...&quot;); // 设置错误属性request.getRequestDispatcher(&quot;userlogin.html&quot;).forward(request, response);&#125; (2).jsp前端代码块 123456789101112&lt;%String errorInfo = (String)request.getAttribute(&quot;loginError&quot;); // 获取错误属性if(errorInfo != null) &#123;%&gt;&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;alert(&quot;&lt;%=errorInfo%&gt;&quot;); // 弹出错误信息window.location=&apos;userlogin.html&apos; ; // 跳转到登录界面&lt;/script&gt; &lt;%&#125;%&gt; 总结三种方式，实质都是通过JavaScript弹出对话框，提示用户密码错误，当用户点击alert确定按钮后自动跳转到登录界面 对话框有三种1.只是提醒，不能对脚本产生任何改变 2.一般用于确认，返回 true 或者 false，所以可以轻松用于 if…else…判断 3.一个带输入的对话框，可以返回用户填入的字符串，常见于某些留言本或者论坛输入内容那里的 插入UBB格式图片","categories":[],"tags":[]},{"title":"jsp实现页面跳转的几种方式","slug":"jsp实现页面跳转的几种方式","date":"2019-11-03T12:52:20.000Z","updated":"2019-11-07T15:54:45.124Z","comments":true,"path":"2019/11/03/jsp实现页面跳转的几种方式/","link":"","permalink":"http://yoursite.com/2019/11/03/jsp实现页面跳转的几种方式/","excerpt":"一、使用href超链接标记（客户端跳转）二、提交表单（客户端跳转）123456789 &lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;page2.jsp&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转1&quot;&gt; &lt;/form&gt; &lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;page2.jsp&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转1&quot;&gt; &lt;/form&gt;","text":"一、使用href超链接标记（客户端跳转）二、提交表单（客户端跳转）123456789 &lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;page2.jsp&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转1&quot;&gt; &lt;/form&gt; &lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;page2.jsp&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转1&quot;&gt; &lt;/form&gt; 三、Javascrip事件（客户端跳转）1234567891011&lt;input type=&quot;button&quot; value=&quot;跳转2&quot; onclick=&quot;next()&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; function next()&#123; window.location = &quot;page2.jsp&quot;; &#125; &lt;/script&gt; 四、使用response对象 (客户端跳转)(重定向)12345 &lt;% response.sendRedirect(&quot;page2.jsp&quot;); %&gt; //sendRedirect()可以带参数传递,后面应该紧跟一句return &lt;% response.setHeader(&quot;Refresh&quot;, &quot;1;url=page2.jsp&quot;); %&gt; //1秒后,刷新,并跳到,page2.jsp页面 五、使用forward动作标记 (服务器端跳转)(转发)12 jsp自带的forword标签来实现跳转 &lt;jsp:forward page=&quot;page2.jsp&quot; /&gt; 六、 使用RequestDispatcher类 (服务器端跳转)(转发) 1 &lt;% request.getRequestDispatcher(&quot;page2.jsp&quot;).forward(request, response);%&gt; response重定向和forward跳转和RequestDispatcher的区别（1）response重定向1234执行完页面的所有代码，再跳转到目标页面。跳转到目标页面后，浏览器地址栏中的URL会改变。在浏览器端重定向。可以跳转到其它服务器上的页面，response.sendRedirect(“http://www.baidu.com”) （2）forward跳转12345forward动作标记之后的代码，不再执行，直接跳转到目标页面。跳转到目标页面后，浏览器地址栏中的URL不会改变。在服务器端重定向。无法跳转到其它服务器上的页面。指定目标页面时，既可以使用绝对路径，也可以使用相对路径。 （3）RequestDispatcher跳转12345执行完所有代码，包括RequestDispatcher之后的所有代码，再跳转到目标页面。跳转到目标页面后，浏览器地址栏中的URL不会改变。在服务器端重定向。无法跳转到其它服务器上的页面。指定目标页面时，只能使用绝对路径。","categories":[],"tags":[]},{"title":"数据库的基本用法","slug":"数据库的基本用法","date":"2019-11-02T12:15:20.000Z","updated":"2019-11-07T13:55:54.026Z","comments":true,"path":"2019/11/02/数据库的基本用法/","link":"","permalink":"http://yoursite.com/2019/11/02/数据库的基本用法/","excerpt":"1.如何在命令行配置mysql数据库找到mysql安装目录的bin文件放置到 path 环境变量中 2.启动/停止 mysql12启动 netstartmysqla停止 mysql net stop mysqla 3.登录/退出 mysql123mysql -hlocalhost -P3306 -uroot -p输入密码 123456退出 mysql exit quit \\q","text":"1.如何在命令行配置mysql数据库找到mysql安装目录的bin文件放置到 path 环境变量中 2.启动/停止 mysql12启动 netstartmysqla停止 mysql net stop mysqla 3.登录/退出 mysql123mysql -hlocalhost -P3306 -uroot -p输入密码 123456退出 mysql exit quit \\q 4.数据类型12binary、int、float、double、char、varchar、text、datetime 5.添加数据库1create databasefirst_db charset utf-8; 6.查看数据库12showdatabases；show create database; 7.删除数据1dropdatabase db1; 8.使用数据表前需要先打开数据表所在的数据库1use db2 9.创建表1234create table student(Id int,stuidchar(10),stunamevarchar(10)); 10.查询当前数据库下有哪些表1showtables 11.查询表结构1sescstudent 12.数据库备份与还原12mysqldump -uroot -p first_db&gt;c:\\123456.sql还原 source c:\\123456.sql 13.数据完整性123主键约束 primary key 特点是非空且唯一两种写法，直接写在字段后，或者写在创建语句最后 primary key（字段名）联合主键 写在创建语句最后 primary key(字段 1，字段 2) 14.设置字段自增长1auto_increment 数据表只有一个自增长列，为主键列 15.外键约束1foreign key 写在创建语句最后 1foreign key (从表字段名) references 主表名（主表字段名） 16.其余约束非空约束 1not null 默认约束 1default 值，注意字符串，需外加单引号 唯一约束 1unique 主键约束和唯一约束的区别，主键无意义，唯一约束可以为 null","categories":[],"tags":[]},{"title":"jsp中request，response，session方法","slug":"jsp中request,response,session的方法","date":"2019-10-31T12:52:20.000Z","updated":"2019-11-06T02:31:17.931Z","comments":true,"path":"2019/10/31/jsp中request,response,session的方法/","link":"","permalink":"http://yoursite.com/2019/10/31/jsp中request,response,session的方法/","excerpt":"一、request对象客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。1.返回指定属性的属性值 1object getAttribute(String name) 2.返回所有可用属性名的枚举 1Enumeration getAttributeNames() 3.返回字符编码方式 1String getCharacterEncoding()","text":"一、request对象客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。1.返回指定属性的属性值 1object getAttribute(String name) 2.返回所有可用属性名的枚举 1Enumeration getAttributeNames() 3.返回字符编码方式 1String getCharacterEncoding() 4.返回请求体的长度（以字节数） 1int getContentLength() 5.得到请求体的MIME类型 1String getContentType() 6.得到请求体中一行的二进制流 1ServletInputStream getInputStream() 7.返回name指定参数的参数值 1String getParameter(String name) 8.返回可用参数名的枚举 1Enumeration getParameterNames() 9.返回包含参数name的所有值的数组 1String[] getParameterValues(String name) 10.返回请求用的协议类型及版本号 1String getProtocol() 11.返回请求用的计划名,如:http.https及ftp等 1String getScheme() 12.返回接受请求的服务器主机名 1String getServerName() 13.返回服务器接受此请求所用的端口号 1int getServerPort() 14.返回解码过了的请求体 1BufferedReader getReader() 15.返回发送此请求的客户端IP地址 1String getRemoteAddr() 16.返回发送此请求的客户端主机名 1String getRemoteHost() 17.设置属性的属性值 1void setAttribute(String key,Object obj) 18.返回一虚拟路径的真实路径 1String getRealPath(String path) 二、response对象response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它，它是HttpServletResponse类的实例。1.返回响应用的是何种字符编码 1String getCharacterEncoding() 2.返回响应的一个二进制输出流 1ServletOutputStream getOutputStream() 3.返回可以向客户端输出字符的一个对象 1PrintWriter getWriter() 4.设置响应头长度 1void setContentLength(int len) 5.设置响应的MIME类型 1void setContentType(String type) 6.重新定向客户端的请求 1sendRedirect(java.lang.String location) 三、session对象session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.1.返回SESSION创建时间 1long getCreationTime() 2.返回SESSION创建时JSP引擎为它设的惟一ID号 1public String getId() 3.返回此SESSION里客户端最近一次请求时间 1long getLastAccessedTime() 4.返回两次请求间隔多长时间此SESSION被取消(ms) 1int getMaxInactiveInterval() 5.返回一个包含此SESSION中所有可用属性的数组 1String[] getValueNames() 6.取消SESSION，使SESSION不可用 1void invalidate() 7.返回服务器创建的一个SESSION,客户端是否已经加入 1boolean isNew() 8.删除SESSION中指定的属性 1void removeValue(String name) 9.设置两次请求间隔多长时间此SESSION被取消(ms) 1void setMaxInactiveInterval()","categories":[],"tags":[]},{"title":"Github博客搭建步骤","slug":"Github博客搭建步骤","date":"2019-10-31T12:15:29.000Z","updated":"2019-11-07T15:54:04.905Z","comments":true,"path":"2019/10/31/Github博客搭建步骤/","link":"","permalink":"http://yoursite.com/2019/10/31/Github博客搭建步骤/","excerpt":"Github个人技术博客搭建步骤一、前期准备1、GitHub账号 注册地址：https://github.com/ 2、Node.js环境 下载地址：https://nodejs.org/download/ 3、Git 软件：下载地址http://git-scm.com/download/","text":"Github个人技术博客搭建步骤一、前期准备1、GitHub账号 注册地址：https://github.com/ 2、Node.js环境 下载地址：https://nodejs.org/download/ 3、Git 软件：下载地址http://git-scm.com/download/ 二、软件安装1、注册GitHub账号 1)Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，此处账号名作为后期个人博客的地址使用2。并且需要勾选Initialize this repository with a README。（如果没有勾选，后期要创建README文件即可） 2)创建一个新的repository(代码仓库), 注意，名称必须是xxx.github.io 格式，并且xxx必须是你在GitHub的用户名。 3)在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，可以访问它。你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 2.安装Node.js 在node.js指定地址下载，采用最新的版本即可。 安装Git. 三、Hexo配置流程1、安装Hexo Hexo 是一款基于 Node.js 的静态博客框架。Hexo 使用 Markdown 解析文章，用户在本地安装Hexo并进行写作，通过一条命令，Hexo即可利用靓丽的主题自动生成静态网页。 1）新建文件夹hexo 首先创建一个文件夹，用来存放Hexo模板和项目，然后进入 hexo 文件夹，鼠标右键点击Git Bash Here。 2）安装hexo基础框架 // 这是安装hexo的基础框架（此处要求已经安装了node.js环境） 第一步：npm install hexo-cli -g 第二步：`hexo init blog 123456789101112131415161718192021222324它就会在当前目录下生成一个blog的文件夹，并在里面生成相关配置信息。第三步：`cd blog`切换到blog目录下第四步：`npm install`安装必备的组件，安装完成之后，`blog`文件夹的目录结构大致如下：// 编译生成静态页面，会在当前目录下生成一个新的叫做public的文件夹。第五步：`hexo g```// 启动本地服务第六步：`hexo s```打开链接[http://localhost:4000](http://localhost:4000/)，看到这样的网页就成功啦。 ``` 2、 hexo主题设置，这里以主题yilia为例进行说明。 1）安装主题（此处当前目录为blog） git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 2）启用主题 cd themes/yilia git pull //获取远程内容 3） 修改配置文件 修改hexo目录下的_config.yml配置文件中的theme属性，将其设置为我们前面克隆下来的主体样式，此处theme: yilia 4） 重启服务 切换到blog目录 hexo g # 重新生成静态文件 hexo s # 启动本地web服务器 现在打开http://localhost:4000，会看到我们已经应用了一个新的主题。 四、部署到GitHub服务器1、使用git命令行部署（optional） 此处我们采用git命令来完成部署的工作。 1) cd d:/hexo/blog git clone https://github.com/cuihuniubi/cuihuniubi.github.io .deploy/cuihuniubi.github.io 将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。 2) hexo generate //生成静态文件 cp -R public/* .deploy/cuihuniubi.github.io //复制文件 cd .deploy/cuihuniubi.github.io //切换目录 git add . //将需要提交的代码添加到暂存区 git commit -m “update” //将暂存区内容提交给本地版本库 git push //推送给远程服务器 简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至cuihuniubi.github.io的git目录下，然后使用git commit命令提交代码到cuihuniubi.github.io这个repo的master branch上。 需要部署的时候，执行第三个步骤。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。 2、 验证 打开浏览器，输入地址：https://cuihuniubi.github.io/ ，就可以看到我们的博客上线了哈哈哈！！！ 五、发布博客内容1、创建博客标题 hexo new “CUIHUNIUBI” 2、编写博客内容 找到创建的md文件，使用编辑器打开，按照Markdown的格式，编写博客内容，编写完成之后，执行以下代码，将博客内容推送到远程服务器上。 hexo generate //生成静态文件 cp -R public/* .deploy/cuihuniubi.github.io //复制文件 cd .deploy/cuihuniubi.github.io //切换目录 git add . //将需要提交的代码添加到暂存区 git commit -m “update” //将暂存区内容提交给本地版本库 git push //推送给远程服务器","categories":[],"tags":[]},{"title":"数据库的查询","slug":"数据库的查询","date":"2019-10-25T05:26:21.000Z","updated":"2019-11-07T15:49:45.989Z","comments":true,"path":"2019/10/25/数据库的查询/","link":"","permalink":"http://yoursite.com/2019/10/25/数据库的查询/","excerpt":"1.数据库查询语句123select 字段 1、字段 2... from 表名 where 条件order by 字段 1、字段 2.. limit 数字 1,数字 2;//*是通配符，表示所有字段 2.关键字1.where 查询条件 2.distinct 查询不重复字段","text":"1.数据库查询语句123select 字段 1、字段 2... from 表名 where 条件order by 字段 1、字段 2.. limit 数字 1,数字 2;//*是通配符，表示所有字段 2.关键字1.where 查询条件 2.distinct 查询不重复字段 3.limit n,m 从 n+1 行开始取，取 m 行，行数从 0 开始 limit n,取前 n 行 4.order by 字段 1通过字段 1 将表从小到大排列 123order by 字段 1 descorder by 字段 1,字段 2先按照字段 1 排列，在字段 1 相同的情况下按照字段 2 排列 3.MYSQL函数1.拼接字符串 1concat(&apos;今天&apos;,&apos;晴天&apos;) 2.计算长度，一个字符，符号，数字占 1 位一个汉字占 3 位 1length(&apos;hello world&apos;) 3.转成大写 1upper(&apos;abcd&apos;) 4.清除左侧空格 1ltrim(&apos; abc&apos;) 清除右侧空格 1rtrim(&apos;abc &apos;) 清除两侧空格 1trim(&apos; abc &apos;) 5.替换字符 将 abccd 中的所有 c 替换成 x 1replace(&apos;abccd&apos;,&apos;c&apos;,&apos;x&apos;) 6.比较字符串大小 1strcmp(&apos;a&apos;,&apos;b&apos;) 7.提取字符串 从第 3 个开始取，取 3 个数学函数 1substring(&apos;abcdefg&apos;,3,3) 8.取 0~1 的随机小数，取不到 0 和 1 1rand(); 9.向上取整 1ceil(); 向下取整 1floor(); 4.模糊查询和分组查询1.模糊查询使用 like 关键字， _代表一个字符 ，%代表任意长度的字 符（0 也是任意长度） 123between and 关键字，表示大于等于第一个数，小于等于第二个数select * from stuinfo where age between 18 and 20 where age &gt;=18 and age&lt;=20; 2.聚合函数 求和 sum，平均 avg，最大 max，最小 min，个数 count(*) 使用聚合函数只有一行结果 3.分组查询 group by 写在 where 后面，order by 前面 1select * from stuinfo group by age; 只有聚合函数和被分组的列有意义 使用 having 对分组结果进行条件查询，写在 group by 后面 count(*)和 count(列名) count(列名)，如果列里面是 null 的，不计入总数 5.数据库连接方式数据库总共有4种连接方式 1.内连接 1SELECT 列名 1,列名 2… FROM 表 1，表 2 WHERE 条件 另一种写法 1SELECT 列名 1,列名 2… FROM 表 1 INNER JOIN 表 2 ON 条件 2.左连接 1SELECT 列名 1,列名 2… FROM 表 1 LEFT JOIN 表 2 ON 条件 3.右连接 1SELECT 列名 1,列名 2… FROM 表 1 RIGHT JOIN 表 2 ON 条件 4.全连接 先左连接再右连接","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-10-13T14:52:20.000Z","updated":"2019-10-31T00:58:41.313Z","comments":true,"path":"2019/10/13/我的第一篇博客/","link":"","permalink":"http://yoursite.com/2019/10/13/我的第一篇博客/","excerpt":"JAVA知识点总结第二章 类和对象 1.面向对象概念： 2.类的创建 12- 语法：public class 类名&#123;&#125;- File---&gt;new---&gt;class---&gt;类名 3.创建对象 12- 类名 对象名=new 类名();- 对象名.方法名(); 对象名.属性","text":"JAVA知识点总结第二章 类和对象 1.面向对象概念： 2.类的创建 12- 语法：public class 类名&#123;&#125;- File---&gt;new---&gt;class---&gt;类名 3.创建对象 12- 类名 对象名=new 类名();- 对象名.方法名(); 对象名.属性 4.构造方法：方法名和类名相同,没有返回值 123- public class 类名&#123;- public 类名()&#123;&#125;//主要的做用是初始化操作- &#125; 5.构造方法重载 在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法 1234- public class 类名&#123;- public 类名()&#123;&#125;- public 类名(String name,int age)&#123;&#125;- &#125; 6.构造方法的执行 12- new 类名();---&gt;执行构造方法- super();---&gt;执行了父类的构造方法 7.static静态修饰符 静态修饰符可以修饰属性，方法，代码块 类名.属性 类名.方法名 8.java内存（栈和堆，static，方法区，gc（垃圾回收机制）） 第三章 面向对象三大特征—封装 1.封装的概念 2.封装的步骤 1.把属性私有化（private） 2.对这些属性设置get和set方法 3.调用处理这些方法 3.封装的作用：避免一些用一些不合乎常理的操作 4.修饰符 1234- public---&gt;公共的：在一个项目中都可以访问，权限最高- private---&gt;私有的：只能在本类中进行访问，权限最低- protected---&gt;安全的，受保护的：同一个包能进行访问，继承中之类可以访问父类- default---&gt;默认的：同一个包能访问 第四章 面向对象三大特征—继承 1.继承的概念：父亲儿子，电影《西虹市首富》 2.继承的关键字：extends 3.继承的语法： 1public class 类名 extends 父类&#123;&#125; 4.使用，在之类中： 可以直接调用父类的非私有属性和方法 可以用super.方法 super.属性 5.父类构造方法调用：super(); 调用父类的构造方法必须在之类中调用 必须实在之类构造方法的第一行代码 6.重写@Override 必须继承 方法名一致，参数个数，顺序，类型全部一致 第五章 面向对象（多态） 1.多态的概念 2.多态的必要条件 继承 重写 父类引用指向子类对象（向上转型） 3.多态的使用 1234567891011121314151617- public class Father&#123;- public void cooking()&#123;- System.out.println(&quot;米饭&quot;);- &#125;- &#125;- public class Son extends Father&#123;- @Override- public void cooking()&#123;- System.out.println(&quot;熬粥&quot;);- &#125;- &#125;- public class Test &#123;- public static void main(String[] args) &#123;- Father son=new Son();- son.cooking();- &#125;- &#125; 4.向下转型 Son son=(Son)father; 第六章 抽象 1.抽象的概念 2.抽象的关键字 abstract 可以修饰类，可以修饰方法 3.抽象的用法 //抽象类 public abstract class 类名{ //抽象方法没有方法体 public abstract void 方法名(); } //当父类是抽象类的时候，子类必须重写父类里面的抽象方法 4.final修饰符：最终的 修饰变量，修饰方法，修饰类 1.当修饰变量时，变量转换成常量，常量的值不能改变 1final int a=18;//a=18;不能改变,必须给一个初始值 2.当修饰方法时，该方法不能被重写 3.当修饰类时，该类不能被继承 第七章 接口 1.接口的概念 2.接口的关键字 interface 3.接口的语法 123- public interface 接口名&#123;&#125;- File---&gt;new---&gt;interface//创建接口- 4.接口的用法 实现接口的关键字 implements public interface 接口名{ //接口是纯抽象类 //接口里面的方法都是抽象方法 12345678910111213- void setData();- &#125;- public class Play implements 接口名&#123;- @Override- void setData()&#123;- &#125;- &#125;- public class Test &#123;- public static void main(String[] args) &#123;- Play play=new Play();- play.setData();- &#125;- &#125; 注意接口可以进行多继承 1public interface 接口名 extends 接口名，接口名&#123;&#125; 一般用法 1public class 类名 extends 父类 implements 接口，接口&#123;&#125; 第八章 集合框架 1.ArrayList 1.用法 123- ArrayList list=new ArrayList();- list.add();//添加数据- list.get();//获取数据 2.Map 用法 123- Map map=new HasMap();- map.put(key,value);//key不能重复- map.get(key);//获取key对象的value 3.泛型 用法 123- ArrayList&lt;String&gt; list=new ArrayList&gt;&lt;String&gt;();- Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();- ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();","categories":[],"tags":[]}]}